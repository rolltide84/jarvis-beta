<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="theme-color" content="#0f172a">
  <title>JARVIS - AI Task Prioritizer</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
  <div id="root"></div>
  
  <script type="text/babel">
    const { useState, useEffect, useCallback } = React;

    // Fixed icon components with proper SVG rendering
    const Icon = ({ children, ...props }) => (
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
        {children}
      </svg>
    );

    const Shield = (props) => <Icon {...props}><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z" /></Icon>;
    const Lock = (props) => <Icon {...props}><path d="M21 12a9 9 0 1 1-6.219-8.56" /><circle cx="12" cy="12" r="3" /></Icon>;
    const Brain = (props) => <Icon {...props}><path d="M9.5 2A2.5 2.5 0 0 1 12 4.5v15a2.5 2.5 0 0 1-4.96.44 2.5 2.5 0 0 1-2.96-3.08 3 3 0 0 1-.34-5.58 2.5 2.5 0 0 1 1.32-4.24 2.5 2.5 0 0 1 1.98-3A2.5 2.5 0 0 1 9.5 2Z" /><path d="M14.5 2A2.5 2.5 0 0 0 12 4.5v15a2.5 2.5 0 0 0 4.96.44 2.5 2.5 0 0 0 2.96-3.08 3 3 0 0 0 .34-5.58 2.5 2.5 0 0 0-1.32-4.24 2.5 2.5 0 0 0-1.98-3A2.5 2.5 0 0 0 14.5 2Z" /></Icon>;
    const Clock = (props) => <Icon {...props}><circle cx="12" cy="12" r="10" /><polyline points="12 6 12 12 16 14" /></Icon>;
    const AlertCircle = (props) => <Icon {...props}><circle cx="12" cy="12" r="10" /><line x1="12" y1="8" x2="12" y2="12" /><line x1="12" y1="16" x2="12.01" y2="16" /></Icon>;
    const Check = (props) => <Icon {...props}><polyline points="20 6 9 17 4 12" /></Icon>;
    const Plus = (props) => <Icon {...props}><line x1="12" y1="5" x2="12" y2="19" /><line x1="5" y1="12" x2="19" y2="12" /></Icon>;
    const Settings = (props) => <Icon {...props}><circle cx="12" cy="12" r="3" /><path d="M12 1v6M12 17v6M4.22 4.22l4.24 4.25M15.54 15.54l4.24 4.25M1 12h6M17 12h6M4.22 19.78l4.24-4.24M15.54 8.46l4.24-4.24" /></Icon>;
    const X = (props) => <Icon {...props}><line x1="18" y1="6" x2="6" y2="18" /><line x1="6" y1="6" x2="18" y2="18" /></Icon>;
    const Eye = (props) => <Icon {...props}><path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z" /><circle cx="12" cy="12" r="3" /></Icon>;
    const Trash2 = (props) => <Icon {...props}><polyline points="3 6 5 6 21 6" /><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2" /><line x1="10" y1="11" x2="10" y2="17" /><line x1="14" y1="11" x2="14" y2="17" /></Icon>;
    const Download = (props) => <Icon {...props}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" /><polyline points="7 10 12 15 17 10" /><line x1="12" y1="15" x2="12" y2="3" /></Icon>;
    const Bell = (props) => <Icon {...props}><path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9" /><path d="M13.73 21a2 2 0 0 1-3.46 0" /></Icon>;
    const Calendar = (props) => <Icon {...props}><rect x="3" y="4" width="18" height="18" rx="2" ry="2" /><line x1="16" y1="2" x2="16" y2="6" /><line x1="8" y1="2" x2="8" y2="6" /><line x1="3" y1="10" x2="21" y2="10" /></Icon>;

    const TIME_OF_DAY = ['morning', 'afternoon', 'evening', 'night'];
    const TASK_TAGS = ['deep_work', 'calls', 'emails', 'meetings', 'creative', 'admin', 'urgent'];

    class EncryptionManager {
      constructor() {
        this.key = null;
      }

      async initialize() {
        const storedKey = localStorage.getItem('encryptionKey');
        if (storedKey) {
          const keyData = JSON.parse(storedKey);
          this.key = await crypto.subtle.importKey('jwk', keyData, { name: 'AES-GCM' }, true, ['encrypt', 'decrypt']);
        } else {
          this.key = await crypto.subtle.generateKey({ name: 'AES-GCM', length: 256 }, true, ['encrypt', 'decrypt']);
          const exportedKey = await crypto.subtle.exportKey('jwk', this.key);
          localStorage.setItem('encryptionKey', JSON.stringify(exportedKey));
        }
      }

      async encrypt(data) {
        const iv = crypto.getRandomValues(new Uint8Array(12));
        const encoded = new TextEncoder().encode(JSON.stringify(data));
        const cipher = await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, this.key, encoded);
        return { iv: Array.from(iv), cipher: Array.from(new Uint8Array(cipher)) };
      }

      async decrypt(encryptedData) {
        const iv = new Uint8Array(encryptedData.iv);
        const cipher = new Uint8Array(encryptedData.cipher);
        const decrypted = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, this.key, cipher);
        const decoded = new TextDecoder().decode(decrypted);
        return JSON.parse(decoded);
      }
    }

    class NotificationManager {
      constructor() {
        this.permission = 'default';
        this.notifiedTasks = new Set();
      }

      async requestPermission() {
        if ('Notification' in window) {
          this.permission = await Notification.requestPermission();
          return this.permission === 'granted';
        }
        return false;
      }

      async notify(title, body, tag) {
        if (this.permission === 'granted' && 'Notification' in window) {
          if (!this.notifiedTasks.has(tag)) {
            new Notification(title, { body, icon: 'ü§ñ', tag, requireInteraction: false });
            this.notifiedTasks.add(tag);
          }
        }
      }

      clearNotified(taskId) {
        this.notifiedTasks.delete(taskId);
      }
    }

    function generateICS(task) {
      const formatDate = (timestamp) => {
        const date = new Date(timestamp);
        return date.toISOString().replace(/[-:]/g, '').split('.')[0] + 'Z';
      };
      const escape = (str) => str.replace(/[,;\\]/g, '\\$&').replace(/\n/g, '\\n');
      const startDate = task.dueAt || Date.now();
      const endDate = startDate + (task.effortMins * 60 * 1000);
      return `BEGIN:VCALENDAR
VERSION:2.0
PRODID:-//JARVIS//Task Scheduler//EN
CALSCALE:GREGORIAN
METHOD:PUBLISH
BEGIN:VEVENT
UID:${task.id}@jarvis
DTSTAMP:${formatDate(Date.now())}
DTSTART:${formatDate(startDate)}
DTEND:${formatDate(endDate)}
SUMMARY:${escape(task.title)}
DESCRIPTION:Priority: ${task.urgency}/5\\nEffort: ${task.effortMins} mins\\nTags: ${task.tags.join(', ')}
STATUS:CONFIRMED
SEQUENCE:0
BEGIN:VALARM
TRIGGER:-PT15M
DESCRIPTION:Task reminder
ACTION:DISPLAY
END:VALARM
END:VEVENT
END:VCALENDAR`;
    }

    function baselineScore(task, context) {
      const now = context.now;
      const hoursToDue = task.dueAt ? Math.max(0, (task.dueAt - now) / (1000 * 60 * 60)) : Infinity;
      const deadlineWeight = task.dueAt ? Math.exp(-hoursToDue / 48) * 5 : 0;
      const urgencyWeight = task.urgency * 2;
      const effort = task.effortMins || 60;
      const effortWeight = context.availableMins >= effort ? 1.0 : 0.6;
      const contextFit = (task.tags.includes(context.timeOfDay) ? 0.5 : 0) + (context.locationTag && task.tags.includes(context.locationTag) ? 0.5 : 0);
      const neglectBoost = task.lastDoneAt ? Math.min(2, Math.log1p((now - task.lastDoneAt) / (1000 * 60 * 60 * 24))) : 0.3;
      return (deadlineWeight + urgencyWeight) * effortWeight + contextFit + neglectBoost;
    }

    class AdaptiveModel {
      constructor(featureCount = 10) {
        this.weights = new Float64Array(featureCount).fill(0);
        this.enabled = true;
      }

      extractFeatures(task, context, baseScore) {
        return new Float64Array([
          baseScore / 10,
          task.urgency / 5,
          (task.effortMins || 60) / 120,
          task.dueAt ? 1 : 0,
          context.timeOfDay === 'morning' ? 1 : 0,
          context.timeOfDay === 'afternoon' ? 1 : 0,
          task.tags.includes('deep_work') ? 1 : 0,
          task.tags.includes('urgent') ? 1 : 0,
          task.completionCount || 0,
          1
        ]);
      }

      predict(features) {
        let z = 0;
        for (let i = 0; i < features.length; i++) {
          z += this.weights[i] * features[i];
        }
        return 1 / (1 + Math.exp(-z));
      }

      update(features, wasSelected, lr = 0.05, l2 = 0.0005) {
        const p = this.predict(features);
        const error = p - (wasSelected ? 1 : 0);
        for (let i = 0; i < features.length; i++) {
          this.weights[i] = this.weights[i] - lr * (error * features[i] + l2 * this.weights[i]);
        }
      }
    }

    function App() {
      const [tasks, setTasks] = useState([]);
      const [completedTasks, setCompletedTasks] = useState([]);
      const [encryption] = useState(new EncryptionManager());
      const [notificationManager] = useState(new NotificationManager());
      const [adaptiveModel] = useState(new AdaptiveModel());
      const [context, setContext] = useState({
        now: Date.now(),
        timeOfDay: 'afternoon',
        availableMins: 60,
        locationTag: null
      });
      const [settings, setSettings] = useState({
        adaptiveAlpha: 0.3,
        enableAdaptive: true,
        explainRankings: true,
        notificationsEnabled: false,
        notificationMinutes: 60
      });
      const [showAddTask, setShowAddTask] = useState(false);
      const [showSettings, setShowSettings] = useState(false);
      const [initialized, setInitialized] = useState(false);

      useEffect(() => {
        encryption.initialize().then(() => {
          loadTasks();
          loadCompletedTasks();
          loadSettings();
          setInitialized(true);
        });
      }, []);

      useEffect(() => {
        const updateContext = () => {
          const hour = new Date().getHours();
          let timeOfDay = 'afternoon';
          if (hour < 12) timeOfDay = 'morning';
          else if (hour < 17) timeOfDay = 'afternoon';
          else if (hour < 21) timeOfDay = 'evening';
          else timeOfDay = 'night';
          setContext(prev => ({ ...prev, now: Date.now(), timeOfDay }));
        };
        updateContext();
        const interval = setInterval(updateContext, 60000);
        return () => clearInterval(interval);
      }, []);

      useEffect(() => {
        if (!settings.notificationsEnabled) return;
        const checkNotifications = () => {
          const now = Date.now();
          const threshold = settings.notificationMinutes * 60 * 1000;
          tasks.forEach(task => {
            if (task.dueAt) {
              const timeUntilDue = task.dueAt - now;
              if (timeUntilDue > 0 && timeUntilDue <= threshold) {
                const minutesLeft = Math.round(timeUntilDue / (1000 * 60));
                notificationManager.notify('JARVIS - Task Due Soon!', `"${task.title}" is due in ${minutesLeft} minutes`, task.id);
              }
            }
          });
        };
        checkNotifications();
        const interval = setInterval(checkNotifications, 60000);
        return () => clearInterval(interval);
      }, [tasks, settings.notificationsEnabled, settings.notificationMinutes]);

      const saveTasks = async (tasksToSave) => {
        try {
          const encrypted = await encryption.encrypt(tasksToSave);
          localStorage.setItem('encryptedTasks', JSON.stringify(encrypted));
        } catch (error) {
          console.error('Failed to save tasks:', error);
        }
      };

      const loadTasks = async () => {
        try {
          const stored = localStorage.getItem('encryptedTasks');
          if (stored) {
            const encrypted = JSON.parse(stored);
            const decrypted = await encryption.decrypt(encrypted);
            setTasks(decrypted);
          }
        } catch (error) {
          console.error('Failed to load tasks:', error);
        }
      };

      const saveCompletedTasks = async (completedToSave) => {
        try {
          const encrypted = await encryption.encrypt(completedToSave);
          localStorage.setItem('encryptedCompletedTasks', JSON.stringify(encrypted));
        } catch (error) {
          console.error('Failed to save completed tasks:', error);
        }
      };

      const loadCompletedTasks = async () => {
        try {
          const stored = localStorage.getItem('encryptedCompletedTasks');
          if (stored) {
            const encrypted = JSON.parse(stored);
            const decrypted = await encryption.decrypt(encrypted);
            setCompletedTasks(decrypted);
          }
        } catch (error) {
          console.error('Failed to load completed tasks:', error);
        }
      };

      const saveSettings = (settingsToSave) => {
        localStorage.setItem('jarvisSettings', JSON.stringify(settingsToSave));
      };

      const loadSettings = () => {
        try {
          const stored = localStorage.getItem('jarvisSettings');
          if (stored) {
            setSettings(prev => ({...prev, ...JSON.parse(stored)}));
          }
        } catch (error) {
          console.error('Failed to load settings:', error);
        }
      };

      const addTask = (taskData) => {
        const newTask = {
          id: crypto.randomUUID(),
          createdAt: Date.now(),
          completionCount: 0,
          ...taskData
        };
        const updatedTasks = [...tasks, newTask];
        setTasks(updatedTasks);
        saveTasks(updatedTasks);
      };

      const completeTask = (taskId) => {
        const taskToComplete = tasks.find(task => task.id === taskId);
        if (!taskToComplete) return;
        if (settings.enableAdaptive && adaptiveModel.enabled) {
          const baseScore = baselineScore(taskToComplete, context);
          const features = adaptiveModel.extractFeatures(taskToComplete, context, baseScore);
          adaptiveModel.update(features, true);
        }
        const completedTask = {
          ...taskToComplete,
          completedAt: Date.now(),
          completionCount: (taskToComplete.completionCount || 0) + 1
        };
        const updatedTasks = tasks.filter(task => task.id !== taskId);
        const updatedCompleted = [...completedTasks, completedTask];
        setTasks(updatedTasks);
        setCompletedTasks(updatedCompleted);
        saveTasks(updatedTasks);
        saveCompletedTasks(updatedCompleted);
        notificationManager.clearNotified(taskId);
      };

      const deleteTask = (taskId) => {
        const updatedTasks = tasks.filter(task => task.id !== taskId);
        setTasks(updatedTasks);
        saveTasks(updatedTasks);
        notificationManager.clearNotified(taskId);
      };

      const downloadCalendarEvent = (task) => {
        const icsContent = generateICS(task);
        const blob = new Blob([icsContent], { type: 'text/calendar;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `${task.title.replace(/[^a-z0-9]/gi, '_')}.ics`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
      };

      const downloadCompletedLog = () => {
        if (completedTasks.length === 0) {
          alert('No completed tasks to download yet!');
          return;
        }
        const logContent = completedTasks.map(task => {
          const completedDate = new Date(task.completedAt).toLocaleString();
          const createdDate = new Date(task.createdAt).toLocaleString();
          const dueDate = task.dueAt ? new Date(task.dueAt).toLocaleString() : 'No deadline';
          return `
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
Task: ${task.title}
Completed: ${completedDate}
Created: ${createdDate}
Due: ${dueDate}
Urgency: ${task.urgency}/5
Effort: ${task.effortMins} minutes
Tags: ${task.tags.join(', ') || 'None'}
Completion Count: ${task.completionCount}
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
`;
        }).join('\n');
        const header = `
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë              JARVIS - COMPLETED TASKS LOG             ‚ïë
‚ïë            Generated: ${new Date().toLocaleString()}            ‚ïë
‚ïë            Total Completed: ${completedTasks.length} tasks                  ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

`;
        const fullLog = header + logContent;
        const blob = new Blob([fullLog], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `JARVIS-completed-tasks-${Date.now()}.txt`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
      };

      const toggleNotifications = async () => {
        if (!settings.notificationsEnabled) {
          // Check if notifications API exists
          if (!('Notification' in window)) {
            alert('‚ùå Notifications are not supported in this browser. Try Chrome, Firefox, or update Safari to the latest version.');
            return;
          }

          // Check current permission
          if (Notification.permission === 'denied') {
            alert('üîí Notifications are blocked. To enable:\n\nSafari ‚Üí Settings for this website ‚Üí Notifications ‚Üí Allow');
            return;
          }

          // For Safari, we need to request permission on user interaction
          try {
            let permission = Notification.permission;
            
            // If not yet asked, request permission
            if (permission === 'default') {
              permission = await Notification.requestPermission();
            }
            
            if (permission === 'granted') {
              const granted = await notificationManager.requestPermission();
              if (granted) {
                const newSettings = {...settings, notificationsEnabled: true};
                setSettings(newSettings);
                saveSettings(newSettings);
                
                // Safari requires notifications to be created immediately after permission
                setTimeout(() => {
                  notificationManager.notify('‚úÖ JARVIS Notifications Enabled!', 'You will now receive task alerts.', 'test');
                }, 100);
              }
            } else {
              alert('‚ö†Ô∏è Notification permission was denied. Enable it in Safari Settings ‚Üí Websites ‚Üí Notifications');
            }
          } catch (error) {
            console.error('Notification error:', error);
            // Safari sometimes throws errors, provide helpful message
            alert('‚ùå Safari notification setup failed. Make sure:\n\n1. You\'re using Safari 16+ on Mac or iOS 16+\n2. Notifications are allowed in System Settings\n3. This website is allowed in Safari Settings');
          }
        } else {
          const newSettings = {...settings, notificationsEnabled: false};
          setSettings(newSettings);
          saveSettings(newSettings);
        }
      };

      const getRankedTasks = useCallback(() => {
        return tasks.map(task => {
          const baseScore = baselineScore(task, context);
          let finalScore = baseScore;
          let adaptiveScore = 0;
          if (settings.enableAdaptive && adaptiveModel.enabled) {
            const features = adaptiveModel.extractFeatures(task, context, baseScore);
            adaptiveScore = adaptiveModel.predict(features);
            finalScore = settings.adaptiveAlpha * baseScore + (1 - settings.adaptiveAlpha) * adaptiveScore * 10;
          }
          const explanation = getExplanation(task, context, baseScore, adaptiveScore);
          return { ...task, baseScore, adaptiveScore, finalScore, explanation };
        }).sort((a, b) => b.finalScore - a.finalScore);
      }, [tasks, context, settings]);

      const getExplanation = (task, context, baseScore, adaptiveScore) => {
        const reasons = [];
        if (task.dueAt) {
          const hours = Math.round((task.dueAt - context.now) / (1000 * 60 * 60));
          if (hours < 0) reasons.push('OVERDUE!');
          else if (hours < 1) reasons.push('Due in <1h');
          else if (hours < 24) reasons.push(`Due in ${hours}h`);
          else reasons.push(`Due in ${Math.round(hours/24)}d`);
        }
        if (task.urgency >= 4) reasons.push('High urgency');
        if (task.tags.includes(context.timeOfDay)) reasons.push(`Fits ${context.timeOfDay}`);
        if (settings.enableAdaptive && adaptiveScore > 0.6) reasons.push('Often chosen');
        if (task.lastDoneAt) {
          const daysSince = Math.round((context.now - task.lastDoneAt) / (1000 * 60 * 60 * 24));
          if (daysSince > 7) reasons.push(`Last done ${daysSince}d ago`);
        }
        return reasons;
      };

      const rankedTasks = getRankedTasks();

      if (!initialized) {
        return (
          <div className="min-h-screen bg-gradient-to-br from-slate-900 to-slate-800 flex items-center justify-center">
            <div className="text-white text-xl flex items-center gap-3">
              <Lock className="w-6 h-6 animate-pulse" />
              <span>Initializing secure storage...</span>
            </div>
          </div>
        );
      }

      return (
        <div className="min-h-screen bg-gradient-to-br from-slate-900 to-slate-800 text-white p-6">
          <div className="max-w-4xl mx-auto">
            <div className="mb-8">
              <div className="flex items-center justify-between mb-4">
                <div className="flex items-center gap-3">
                  <Brain className="w-8 h-8 text-blue-400" />
                  <h1 className="text-3xl font-bold">JARVIS</h1>
                </div>
                <div className="flex items-center gap-4">
                  <div className="flex items-center gap-2 bg-green-900/30 px-3 py-1 rounded-full text-sm">
                    <Shield className="w-4 h-4 text-green-400" />
                    <span className="text-green-300">Local-Only</span>
                  </div>
                  {settings.notificationsEnabled && (
                    <div className="flex items-center gap-2 bg-blue-900/30 px-3 py-1 rounded-full text-sm">
                      <Bell className="w-4 h-4 text-blue-400" />
                      <span className="text-blue-300">Alerts On</span>
                    </div>
                  )}
                  <button onClick={downloadCompletedLog} className="p-2 hover:bg-slate-700 rounded-lg transition-colors">
                    <Download className="w-5 h-5" />
                  </button>
                  <button onClick={() => setShowSettings(!showSettings)} className="p-2 hover:bg-slate-700 rounded-lg transition-colors">
                    <Settings className="w-5 h-5" />
                  </button>
                </div>
              </div>
              <div className="flex items-center gap-6 text-sm text-slate-400">
                <div className="flex items-center gap-2">
                  <Clock className="w-4 h-4" />
                  <span className="capitalize">{context.timeOfDay}</span>
                </div>
                <div className="flex items-center gap-2">
                  <AlertCircle className="w-4 h-4" />
                  <span>{context.availableMins} mins available</span>
                </div>
                <div className="flex items-center gap-2">
                  <Check className="w-4 h-4 text-green-400" />
                  <span>{completedTasks.length} completed</span>
                </div>
              </div>
            </div>

            {showSettings && <SettingsPanel settings={settings} setSettings={setSettings} saveSettings={saveSettings} toggleNotifications={toggleNotifications} context={context} setContext={setContext} />}

            <button onClick={() => setShowAddTask(!showAddTask)} className="w-full bg-blue-600 hover:bg-blue-700 rounded-lg p-4 mb-6 flex items-center justify-center gap-2 transition-colors">
              <Plus className="w-5 h-5" />
              <span>Add New Task</span>
            </button>

            {showAddTask && <TaskForm onAdd={addTask} onCancel={() => setShowAddTask(false)} />}

            <div className="space-y-3">
              {rankedTasks.length === 0 ? (
                <div className="text-center py-12 text-slate-400">
                  <Brain className="w-16 h-16 mx-auto mb-4 opacity-50" />
                  <p>No active tasks. Add your first task to get started!</p>
                </div>
              ) : (
                rankedTasks.map((task, index) => (
                  <TaskCard key={task.id} task={task} rank={index + 1} showExplanation={settings.explainRankings} onComplete={completeTask} onDelete={deleteTask} onDownloadCalendar={downloadCalendarEvent} />
                ))
              )}
            </div>

            <div className="mt-8 text-center text-sm text-slate-500 space-y-1">
              <p className="flex items-center justify-center gap-2">
                <Lock className="w-4 h-4" />
                All data encrypted and stored locally
              </p>
              <p>No cloud sync ‚Ä¢ No telemetry ‚Ä¢ No external calls</p>
            </div>
          </div>
        </div>
      );
    }

    function SettingsPanel({ settings, setSettings, saveSettings, toggleNotifications, context, setContext }) {
      return (
        <div className="bg-slate-800 rounded-lg p-6 mb-6 border border-slate-700">
          <h2 className="text-xl font-semibold mb-4 flex items-center gap-2">
            <Settings className="w-5 h-5" />
            Settings
          </h2>
          <div className="space-y-4">
            <div>
              <label className="flex items-center justify-between mb-2">
                <span>Enable Notifications</span>
                <input type="checkbox" checked={settings.notificationsEnabled} onChange={toggleNotifications} className="w-5 h-5" />
              </label>
              <p className="text-sm text-slate-400">Get notified when tasks are almost due</p>
            </div>
            {settings.notificationsEnabled && (
              <div>
                <label className="block mb-2">Notify me {settings.notificationMinutes} minutes before</label>
                <input type="range" min="15" max="180" step="15" value={settings.notificationMinutes} onChange={(e) => { const newSettings = {...settings, notificationMinutes: parseInt(e.target.value)}; setSettings(newSettings); saveSettings(newSettings); }} className="w-full" />
              </div>
            )}
            <div>
              <label className="flex items-center justify-between mb-2">
                <span>Enable Adaptive Learning</span>
                <input type="checkbox" checked={settings.enableAdaptive} onChange={(e) => { const newSettings = {...settings, enableAdaptive: e.target.checked}; setSettings(newSettings); saveSettings(newSettings); }} className="w-5 h-5" />
              </label>
              <p className="text-sm text-slate-400">Learn from your task choices to improve rankings</p>
            </div>
            {settings.enableAdaptive && (
              <div>
                <label className="block mb-2">Adaptive Influence: {Math.round((1 - settings.adaptiveAlpha) * 100)}%</label>
                <input type="range" min="0" max="1" step="0.1" value={settings.adaptiveAlpha} onChange={(e) => { const newSettings = {...settings, adaptiveAlpha: parseFloat(e.target.value)}; setSettings(newSettings); saveSettings(newSettings); }} className="w-full" />
                <p className="text-sm text-slate-400 mt-1">Balance between rule-based and learned preferences</p>
              </div>
            )}
            <div>
              <label className="block mb-2">Available Time: {context.availableMins} mins</label>
              <input type="range" min="15" max="240" step="15" value={context.availableMins} onChange={(e) => setContext({...context, availableMins: parseInt(e.target.value)})} className="w-full" />
            </div>
            <div>
              <label className="flex items-center justify-between">
                <span>Show Explanations</span>
                <input type="checkbox" checked={settings.explainRankings} onChange={(e) => { const newSettings = {...settings, explainRankings: e.target.checked}; setSettings(newSettings); saveSettings(newSettings); }} className="w-5 h-5" />
              </label>
            </div>
          </div>
        </div>
      );
    }

    function TaskForm({ onAdd, onCancel }) {
      const [formData, setFormData] = useState({ title: '', urgency: 3, effortMins: 60, dueAt: null, tags: [] });
      const handleSubmit = () => {
        if (formData.title.trim()) {
          onAdd(formData);
          onCancel();
        }
      };
      const toggleTag = (tag) => {
        setFormData(prev => ({ ...prev, tags: prev.tags.includes(tag) ? prev.tags.filter(t => t !== tag) : [...prev.tags, tag] }));
      };
      return (
        <div className="bg-slate-800 rounded-lg p-6 mb-6 border border-slate-700">
          <div className="space-y-4">
            <div>
              <label className="block mb-2 text-sm font-medium">Task Title</label>
              <input type="text" value={formData.title} onChange={(e) => setFormData({...formData, title: e.target.value})} className="w-full bg-slate-700 border border-slate-600 rounded-lg px-4 py-2" placeholder="What needs to be done?" />
            </div>
            <div className="grid grid-cols-2 gap-4">
              <div>
                <label className="block mb-2 text-sm font-medium">Urgency: {formData.urgency}/5</label>
                <input type="range" min="1" max="5" value={formData.urgency} onChange={(e) => setFormData({...formData, urgency: parseInt(e.target.value)})} className="w-full" />
              </div>
              <div>
                <label className="block mb-2 text-sm font-medium">Effort: {formData.effortMins} mins</label>
                <input type="range" min="15" max="240" step="15" value={formData.effortMins} onChange={(e) => setFormData({...formData, effortMins: parseInt(e.target.value)})} className="w-full" />
              </div>
            </div>
            <div>
              <label className="block mb-2 text-sm font-medium">Complete By (Date & Time)</label>
              <input type="datetime-local" onChange={(e) => setFormData({...formData, dueAt: e.target.value ? new Date(e.target.value).getTime() : null})} className="w-full bg-slate-700 border border-slate-600 rounded-lg px-4 py-2" />
              <p className="text-xs text-slate-400 mt-1">Set when this task must be completed</p>
            </div>
            <div>
              <label className="block mb-2 text-sm font-medium">Tags</label>
              <div className="flex flex-wrap gap-2">
                {TASK_TAGS.map(tag => (
                  <button key={tag} onClick={() => toggleTag(tag)} className={`px-3 py-1 rounded-full text-sm transition-colors ${formData.tags.includes(tag) ? 'bg-blue-600 text-white' : 'bg-slate-700 text-slate-300 hover:bg-slate-600'}`}>
                    {tag.replace('_', ' ')}
                  </button>
                ))}
              </div>
            </div>
            <div className="flex gap-3">
              <button onClick={handleSubmit} className="flex-1 bg-blue-600 hover:bg-blue-700 rounded-lg py-2 font-medium">Add Task</button>
              <button onClick={onCancel} className="flex-1 bg-slate-700 hover:bg-slate-600 rounded-lg py-2 font-medium">Cancel</button>
            </div>
          </div>
        </div>
      );
    }

    function TaskCard({ task, rank, showExplanation, onComplete, onDelete, onDownloadCalendar }) {
      const getRankColor = (rank) => {
        if (rank === 1) return 'bg-yellow-500';
        if (rank === 2) return 'bg-slate-400';
        if (rank === 3) return 'bg-orange-600';
        return 'bg-slate-600';
      };
      const isOverdue = task.dueAt && task.dueAt < Date.now();
      return (
        <div className={`bg-slate-800 rounded-lg p-4 border transition-colors ${isOverdue ? 'border-red-500 bg-red-900/10' : 'border-slate-700 hover:border-slate-600'}`}>
          <div className="flex items-start gap-4">
            <div className={`${getRankColor(rank)} w-8 h-8 rounded-full flex items-center justify-center font-bold text-sm flex-shrink-0`}>{rank}</div>
            <div className="flex-1 min-w-0">
              <h3 className="font-semibold text-lg mb-2">{task.title}</h3>
              <div className="flex flex-wrap gap-2 mb-2">
                {task.tags.map(tag => (
                  <span key={tag} className="bg-slate-700 px-2 py-1 rounded text-xs">{tag.replace('_', ' ')}</span>
                ))}
              </div>
              <div className="flex items-center gap-4 text-sm text-slate-400 mb-2">
                <span>Urgency: {task.urgency}/5</span>
                <span>Effort: {task.effortMins}m</span>
                {task.dueAt && <span className={isOverdue ? 'text-red-400 font-semibold' : ''}>{isOverdue ? '‚ö†Ô∏è OVERDUE' : `Due: ${new Date(task.dueAt).toLocaleString()}`}</span>}
              </div>
              {showExplanation && task.explanation.length > 0 && (
                <div className="flex items-center gap-2 flex-wrap mt-2">
                  <Eye className="w-4 h-4 text-blue-400" />
                  {task.explanation.map((reason, i) => (
                    <span key={i} className={`px-2 py-1 rounded text-xs ${reason.includes('OVERDUE') ? 'bg-red-900/50 text-red-300' : 'bg-blue-900/30 text-blue-300'}`}>{reason}</span>
                  ))}
                </div>
              )}
            </div>
            <div className="flex gap-2 flex-shrink-0">
              <button onClick={() => onDownloadCalendar(task)} className="p-2 bg-purple-600 hover:bg-purple-700 rounded-lg transition-colors" title="Add to calendar">
                <Calendar className="w-5 h-5" />
              </button>
              <button onClick={() => onComplete(task.id)} className="p-2 bg-green-600 hover:bg-green-700 rounded-lg transition-colors" title="Complete">
                <Check className="w-5 h-5" />
              </button>
              <button onClick={() => onDelete(task.id)} className="p-2 bg-red-600 hover:bg-red-700 rounded-lg transition-colors" title="Delete">
                <Trash2 className="w-5 h-5" />
              </button>
            </div>
          </div>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
